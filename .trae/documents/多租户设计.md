# 多租户技术方案设计

## 架构概述
Staoo Admin系统将采用基于租户ID的多租户架构，通过在数据层、业务层和接口层添加租户标识来实现数据隔离和权限控制。

## 技术选型
- **租户隔离策略**：基于字段的隔离策略，所有业务表添加tenant_id字段
- **租户上下文管理**：基于ThreadLocal的租户上下文
- **数据源**：单数据源，通过SQL过滤实现数据隔离
- **中间件**：
  - 数据库：MySQL 8.0
  - 缓存：Redis
  - 消息队列：AMQP

## 核心模块设计

### 1. 租户实体设计
```java
@Data
public class Tenant {
    private Long id;              // 租户ID
    private String tenantName;    // 租户名称
    private String remark;        // 租户备注
    private Integer status;       // 租户状态（0：正常，1：停用）
    private Integer sort;         // 租户排序
    private String tenantParams;  // 租户参数
    private String contactPhone;  // 租户联系电话
    private String contactEmail;  // 租户联系邮箱
    private String contactAddress;// 租户联系地址
    private String contactPerson; // 租户联系人
    private String personPhone;   // 租户联系人电话
    private String personEmail;   // 租户联系人邮箱
    private String personAddress; // 租户联系人地址
    private String personParams;  // 租户联系人参数
    private Date createTime;      // 创建时间
    private Date updateTime;      // 更新时间
}
```

### 2. 租户上下文管理
```java
public class TenantContext {
    private static final ThreadLocal<Long> CURRENT_TENANT = new ThreadLocal<>();
    
    public static void setTenantId(Long tenantId) {
        CURRENT_TENANT.set(tenantId);
    }
    
    public static Long getTenantId() {
        return CURRENT_TENANT.get();
    }
    
    public static void clear() {
        CURRENT_TENANT.remove();
    }
}
```

### 3. 租户拦截器
```java
@Component
public class TenantInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从请求头或token中获取租户ID
        String tenantIdStr = request.getHeader("X-Tenant-Id");
        if (StringUtils.hasText(tenantIdStr)) {
            Long tenantId = Long.parseLong(tenantIdStr);
            TenantContext.setTenantId(tenantId);
        }
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 清理租户上下文
        TenantContext.clear();
    }
}
```

### 4. MyBatis多租户插件
```java
@Intercepts({
    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class})
})
public class TenantInterceptor implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 获取租户ID
        Long tenantId = TenantContext.getTenantId();
        if (tenantId != null) {
            // 拦截SQL并添加租户条件
            // ...
        }
        return invocation.proceed();
    }
    
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    
    @Override
    public void setProperties(Properties properties) {
        // 设置属性
    }
}
```

### 5. 缓存键设计
```java
public class CacheKeyUtil {
    public static String buildTenantCacheKey(Long tenantId, String key) {
        return "tenant:" + tenantId + ":" + key;
    }
}
```

### 6. 消息队列租户标识
```java
public class MessageUtil {
    public static void sendTenantMessage(String queueName, Long tenantId, Object message) {
        // 添加租户ID到消息头
        MessageHeaders headers = new MessageHeaders(Collections.singletonMap("tenantId", tenantId));
        Message<Object> msg = MessageBuilder.createMessage(message, headers);
        // 发送消息
        // ...
    }
}
```

## 数据库设计
- 所有业务表添加`tenant_id`字段，类型为`bigint`
- `tenant_id`字段添加索引以提高查询效率
- 租户表`sys_tenant`存储租户信息
- 系统管理员租户ID为0，不受租户限制

## 接口设计
- 所有接口添加`X-Tenant-Id`请求头
- 租户管理接口设计：
  - `GET /api/system/tenant/list` - 获取租户列表
  - `POST /api/system/tenant` - 创建租户
  - `GET /api/system/tenant/{id}` - 获取租户详情
  - `PUT /api/system/tenant/{id}` - 更新租户
  - `DELETE /api/system/tenant/{id}` - 删除租户

## 安全性考虑
- 租户数据严格隔离，防止越权访问
- 租户上下文清理，防止内存泄漏
- 系统管理员操作需要额外的权限校验

## 测试策略
- 单元测试：测试租户上下文、拦截器、MyBatis插件等组件
- 集成测试：测试多租户场景下的数据隔离和权限控制
- 性能测试：测试多租户环境下的系统性能