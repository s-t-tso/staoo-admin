# 数据同步技术方案设计

## 架构概述
Staoo Admin系统的数据同步功能将基于消息队列和RESTful API实现，提供组织架构和用户数据的查询接口，以及数据变更的订阅和通知机制。系统将采用发布-订阅模式，确保数据变更能够及时、可靠地通知到已订阅的第三方应用。

## 技术选型
- **消息队列**：RabbitMQ (AMQP协议)
- **缓存**：Redis
- **数据库**：MySQL 8.0
- **工作流引擎**：Flowable 7.1.0
- **HTTP客户端**：OkHttp 4.9.0
- **序列化框架**：Jackson

## 核心模块设计

### 1. 数据接口模块
```java
@RestController
@RequestMapping("/api/third-party/data")
public class DataController {
    @Autowired
    private OrgService orgService;
    @Autowired
    private UserService userService;
    
    @GetMapping("/org")
    public ResponseEntity<List<DepartmentDTO>> getOrganization(@RequestHeader("X-Tenant-Id") Long tenantId) {
        // 验证权限
        // 获取组织架构数据
        List<DepartmentDTO> departments = orgService.getFullOrgStructure(tenantId);
        return ResponseEntity.ok(departments);
    }
    
    @GetMapping("/users")
    public ResponseEntity<PageResult<UserDTO>> getUsers(
            @RequestHeader("X-Tenant-Id") Long tenantId,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize,
            @RequestParam(required = false) String keyword) {
        // 验证权限
        // 构建分页查询参数
        PageQuery query = new PageQuery();
        query.setPageNum(pageNum);
        query.setPageSize(pageSize);
        // 获取用户列表
        PageResult<UserDTO> users = userService.queryUsersByTenant(tenantId, keyword, query);
        return ResponseEntity.ok(users);
    }
}
```

### 2. 订阅管理模块
```java
@Data
public class DataSubscription {
    private Long id;
    private String appKey;             // 应用标识
    private String dataType;           // 数据类型（ORG：组织架构，USER：用户，FLOW：流程）
    private String callbackUrl;        // 回调地址
    private String status;             // 状态（0：启用，1：禁用）
    private Date createTime;           // 创建时间
    private Date updateTime;           // 更新时间
}

public interface SubscriptionService {
    // 订阅数据变更
    void subscribe(String appKey, String dataType, String callbackUrl);
    
    // 取消订阅数据变更
    void unsubscribe(String appKey, String dataType);
    
    // 获取应用的所有订阅
    List<DataSubscription> getAppSubscriptions(String appKey);
    
    // 获取指定数据类型的所有订阅
    List<DataSubscription> getSubscriptionsByDataType(String dataType);
    
    // 启用/禁用订阅
    void changeSubscriptionStatus(Long subscriptionId, String status);
}
```

### 3. 消息通知模块
```java
public interface NotificationService {
    // 发送数据变更通知
    void sendDataChangeNotification(String dataType, Long tenantId, Object data, String changeType);
    
    // 发送流程变更通知
    void sendFlowChangeNotification(Long flowInstanceId, String status, Object result);
    
    // 处理通知结果
    void handleNotificationResult(String messageId, boolean success, String errorMessage);
}

@Service
public class NotificationServiceImpl implements NotificationService {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @Autowired
    private SubscriptionService subscriptionService;
    
    @Override
    public void sendDataChangeNotification(String dataType, Long tenantId, Object data, String changeType) {
        // 构建通知消息
        NotificationMessage message = new NotificationMessage();
        message.setMessageId(UUID.randomUUID().toString());
        message.setDataType(dataType);
        message.setTenantId(tenantId);
        message.setData(data);
        message.setChangeType(changeType);
        message.setSendTime(new Date());
        
        // 获取订阅该数据类型的应用
        List<DataSubscription> subscriptions = subscriptionService.getSubscriptionsByDataType(dataType);
        
        // 发送通知到消息队列
        for (DataSubscription subscription : subscriptions) {
            if ("0".equals(subscription.getStatus())) { // 只发送给启用的订阅
                rabbitTemplate.convertAndSend("data-change-exchange", 
                                             subscription.getAppKey(), 
                                             message);
            }
        }
    }
    
    // 其他方法实现...
}
```

### 4. 消息消费者模块
```java
@Component
public class NotificationConsumer {
    @Autowired
    private OkHttpClient httpClient;
    @Autowired
    private NotificationService notificationService;
    
    @RabbitListener(queues = "data-change-queue")
    public void handleDataChangeNotification(NotificationMessage message, Channel channel, Message amqpMessage) throws IOException {
        String appKey = message.getAppKey();
        String callbackUrl = message.getCallbackUrl();
        
        try {
            // 构建HTTP请求
            RequestBody body = RequestBody.create(
                new ObjectMapper().writeValueAsString(message),
                MediaType.parse("application/json; charset=utf-8")
            );
            
            Request request = new Request.Builder()
                .url(callbackUrl)
                .post(body)
                .build();
            
            // 发送HTTP请求
            try (Response response = httpClient.newCall(request).execute()) {
                if (response.isSuccessful()) {
                    // 通知成功，确认消息
                    channel.basicAck(amqpMessage.getMessageProperties().getDeliveryTag(), false);
                    notificationService.handleNotificationResult(message.getMessageId(), true, null);
                } else {
                    // 通知失败，拒绝消息并放入重试队列
                    channel.basicNack(amqpMessage.getMessageProperties().getDeliveryTag(), false, true);
                    notificationService.handleNotificationResult(message.getMessageId(), false, "HTTP response not successful");
                }
            }
        } catch (Exception e) {
            // 异常处理，拒绝消息并放入重试队列
            channel.basicNack(amqpMessage.getMessageProperties().getDeliveryTag(), false, true);
            notificationService.handleNotificationResult(message.getMessageId(), false, e.getMessage());
        }
    }
}
```

### 5. 动态流程接口模块
```java
@RestController
@RequestMapping("/api/third-party/flow")
public class FlowController {
    @Autowired
    private RuntimeService runtimeService;
    
    @PostMapping("/start")
    public ResponseEntity<Map<String, Object>> startFlow(
            @RequestHeader("X-Tenant-Id") Long tenantId,
            @RequestBody FlowStartRequest request) {
        // 验证权限
        // 构建流程变量
        Map<String, Object> variables = new HashMap<>();
        variables.putAll(request.getVariables());
        variables.put("tenantId", tenantId);
        variables.put("appKey", request.getAppKey());
        
        // 启动流程
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(request.getFlowKey(), variables);
        
        // 返回流程实例ID
        Map<String, Object> result = new HashMap<>();
        result.put("processInstanceId", processInstance.getId());
        return ResponseEntity.ok(result);
    }
}
```

## 数据库设计
- 创建数据订阅表`sys_data_subscription`存储订阅信息
- 创建数据同步日志表`sys_data_sync_log`存储同步日志
- 创建通知消息表`sys_notification_message`存储通知消息
- 创建通知结果表`sys_notification_result`存储通知结果

## 消息队列设计
- **交换机**：`data-change-exchange` (扇形交换机)
- **队列**：`data-change-queue` (主队列)
- **重试队列**：`data-change-retry-queue` (重试队列，配置TTL和死信交换机)
- **死信队列**：`data-change-dead-letter-queue` (死信队列，存储超过重试次数的消息)
- **流程通知队列**：`flow-change-queue` (流程变更通知队列)

## 接口设计
- **数据查询接口**：
  - `GET /api/third-party/data/org` - 获取组织架构数据
  - `GET /api/third-party/data/users` - 获取用户列表数据
- **订阅管理接口**：
  - `POST /api/third-party/data/subscribe` - 订阅数据变更
  - `POST /api/third-party/data/unsubscribe` - 取消订阅数据变更
  - `GET /api/third-party/data/subscriptions` - 获取订阅列表
- **动态流程接口**：
  - `POST /api/third-party/flow/start` - 发起流程

## 安全性考虑
- 所有接口需要进行认证和授权校验
- 敏感数据传输使用HTTPS
- 消息内容加密存储和传输
- 防止重放攻击，使用消息ID和时间戳
- 接口访问频率限制

## 性能优化
- 使用Redis缓存热点数据
- 数据库索引优化
- 批量处理数据变更通知
- 异步处理消息发送和日志记录
- 消息队列集群部署，提高吞吐量

## 测试策略
- 单元测试：测试各个模块的核心功能
- 集成测试：测试数据同步和通知的完整流程
- 压力测试：测试高并发场景下的系统性能
- 可靠性测试：测试消息队列的可靠性和重试机制