# 后端开发规则文档

## 包结构规范
每个模块的包结构应严格遵循以下规范，：

```
com.example.模块名
├── config/          # 配置相关类
├── controller/      # 控制器层
├── domain/          # 数据库相关实体
├── enums/           # 枚举类
├── util/            # 工具类
├── mapper/          # MyBatis接口
├── mapstruct/       # 实体转换接口
├── pojo/            # 数据传输对象
│   ├── request/     # 请求类
│   └── response/    # 返回类
└── service/         # 服务实现
```
### 模块规范
- 每个模块遵循单一原则，职责清晰
- 每个模块的包结构应严格遵循以上规范
- 每个模块相对独立，比如system只和系统设置，用户管理组织管理有关，project只和项目管理有关，Flowable只和动态流程、表单、审核有关，job只和xx-job任务有关
- 每个模块的包结构应与模块名保持一致，比如system模块的包结构为com.example.system

### 各包职责说明
- **config**：存放所有配置类，如数据源配置、Web配置、安全配置等
- **controller**：处理HTTP请求，调用Service层业务逻辑，返回统一格式响应
- **domain**：存放与数据库表对应的实体类，包含JPA/MyBatis注解
- **enums**：存放系统中所有枚举类型，如状态枚举、错误码枚举等
- **util**：存放通用工具类，如日期工具、字符串工具、加密工具等
- **mapper**：存放MyBatis的Mapper接口，定义数据访问方法
- **mapstruct**：存放MapStruct的转换器接口，用于实体间转换
- **pojo.request**：存放所有请求参数的DTO类（对于参数的校验，需要使用注解的方式在DTO类中解决，如果遇到复杂的校验，需要根据业务场景自定义校验注解）
- **pojo.response**：存放所有响应数据的DTO类
- **service**：存放业务逻辑实现类

## 实体转换规则
- 所有数据库实体（domain包下的类）**禁止直接作为接口返回对象**
- 必须通过MapStruct将数据库实体转换为response对象后再返回
- 转换逻辑应在mapstruct包中定义，遵循单一职责原则
- 转换过程中应处理好空值、枚举类型等特殊情况
- 转换过程中处理好一对一，一对多，多对多的关系
- 转换过程中对于时间类型处理，需要进行格式化


## Ajax统一返回格式
在common模块中定义和实现统一的响应格式：

### Ajax.success 方法
- 用于返回成功的响应
- 包含状态码、消息和数据
- 结构示例：
  ```json
  {
    "code": 200,
    "message": "操作成功",
    "data": {}
  }
  ```

### Ajax.error 方法
- 用于返回错误的响应
- 包含错误码、错误消息
- 结构示例：
  ```json
  {
    "code": 500,
    "message": "操作失败",
    "data": null
  }
  ```

### 列表统一返回
列表数据应包含分页信息和数据列表：
- 总条数(total)
- 每页条数(pageSize)
- 当前页码(pageNum)
- 数据列表(list)

## Controller层规范
- 所有Controller方法的返回值必须使用Ajax.success或Ajax.error包装
- 方法签名应清晰，参数使用pojo.request包下的请求类
- 方法应添加适当的SpringDoc注解，如@Operation、@ApiResponse等
- 权限控制注解应添加在Controller方法上
- 避免在Controller层处理复杂业务逻辑

## SQL规范
- 所有SQL语句必须使用MyBatis的Mapper接口进行执行
- 避免在业务层直接编写SQL语句
- 所有SQL语句必须使用参数化查询，防止SQL注入攻击
- 尽量不要使用in查询，避免性能问题，可以使用join查询替代
- 避免使用select *，而是指定需要的字段
- 避免使用order by rand()，而是使用order by 主键字段
- 避免使用子查询，而是使用连接查询
- 避免使用n+1查询问题，即查询主表后，再根据主表的结果查询从表。
- 默认使用id逆序查询，即最新的数据在前面

## 异常处理机制
### 统一异常拦截器
- 在framework模块中实现全局异常拦截器
- 分别处理以下类型的异常：
  - 通用异常（Exception）
  - 自定义业务异常（BusinessException）
  - 数据库异常（DataAccessException等）
  - 验证异常（MethodArgumentNotValidException等）

### 自定义异常类
- 创建自定义业务异常类，继承RuntimeException
- 异常类应包含错误码、错误消息等信息
- 业务层应根据具体情况抛出对应的自定义异常

### 异常状态和返回码
- 使用枚举定义所有异常状态和返回码
- 错误码应具有唯一性和可读性
- 错误消息应清晰明了，便于问题定位

## 设计模式应用规范
### 桥接模式
- 适用于需要将抽象部分与实现部分分离的场景
- 例如：日志系统中，日志级别与输出方式的分离

### 组装模式
- 适用于构建复杂对象的场景
- 例如：构建复杂的查询条件、配置对象

### 责任链模式
- 适用于请求需要经过多个处理环节的场景
- 例如：权限校验链、参数验证链

### 工厂模式
- 适用于创建对象需要复杂逻辑的场景
- 例如：创建不同类型的服务实例、创建不同类型的消息

### 策略模式
- 适用于算法需要灵活切换的场景
- 例如：不同的支付方式、不同的排序算法

## 数据库操作规范
- 所有数据库操作应通过MyBatis的Mapper接口进行
- 避免在业务层直接编写SQL语句
- 事务管理应使用Spring的@Transactional注解
- 复杂查询应使用QueryWrapper或XML映射文件

## 安全规范
- 接口访问必须进行权限校验
- 敏感数据传输应进行加密
- 输入参数必须进行校验，防止SQL注入、XSS等攻击
- 密码存储应使用加盐哈希算法

## 性能优化
- 合理使用缓存，减少数据库访问
- 避免N+1查询问题
- 批量操作应使用批处理API
- 大文件处理应考虑异步和分片

## 日志规范
- 使用SLF4J + Logback进行日志记录
- 日志级别应合理设置（DEBUG、INFO、WARN、ERROR）
- 关键操作必须记录日志，包含操作人、操作时间、操作内容等信息
- 异常日志必须包含异常栈信息

## 接口文档规范
- 使用SpringDoc自动生成API接口文档
- 所有接口方法必须添加清晰的注解说明
- 参数和返回值必须有详细的描述
- 文档应包含接口测试功能

## 编码规范细节
- 缩进：统一使用4个空格，禁止使用Tab键
- 行宽限制：每行代码不超过120个字符，超出需要换行
- 大括号使用：采用Egyptian风格（不换行）
- 空行：方法间空一行，逻辑块间可空一行提高可读性
- 变量声明：一行只声明一个变量
- 运算符前后：必须有空格，如 `a + b = c`
- 方法参数：逗号后面必须有空格，如 `method(a, b, c)`
- 代码块：逻辑相关的代码应放在一起，使用空行分隔不同的逻辑块

## 集合泛型使用
- 禁止使用原始类型（raw type），必须指定泛型参数
- 集合声明时必须指定泛型类型，如 `List<String> list = new ArrayList<>();`
- 使用泛型上限和下限提高代码灵活性，如 `<? extends T>` 表示上界，`<? super T>` 表示下界
- 集合初始化时推荐使用菱形操作符（Diamond Operator）`<>`, 如 `new ArrayList<>()`
- 集合转换时注意类型安全，必要时使用类型检查和转换

## 并发编程
- 优先使用CompletableFuture处理异步操作
- 线程安全集合：在多线程环境下，使用ConcurrentHashMap、CopyOnWriteArrayList等线程安全集合
- 锁机制：合理使用synchronized关键字或ReentrantLock，避免死锁
- 线程池：使用线程池管理线程资源，避免频繁创建和销毁线程
- 避免共享可变状态，使用不可变对象或线程局部变量
- 使用Atomic类进行原子操作，如AtomicInteger、AtomicReference
- 并发工具类：合理使用CountDownLatch、CyclicBarrier、Semaphore等并发工具

## 单元测试规范
- 测试框架：使用JUnit 5进行单元测试
- 断言工具：优先使用AssertJ提供更流畅的断言API
- 测试命名：测试方法命名应清晰表达测试意图，如 `shouldReturnSuccessWhenValidInput()`
- 测试覆盖：关键业务逻辑、复杂算法、边界条件必须有单元测试覆盖
- 测试隔离：测试用例之间应相互独立，不依赖执行顺序
- 模拟对象：使用Mockito等工具模拟依赖，提高测试的可控性
- 测试数据：使用测试数据构建器或测试数据集，避免硬编码测试数据
- 集成测试：API接口、数据库操作等应编写集成测试

## 性能优化细节
- 数据库优化：合理设计索引，避免全表扫描；使用合适的查询条件
- 连接池：配置合适的数据库连接池参数，如最小连接数、最大连接数
- 对象池化：对创建成本高的对象（如数据库连接、线程）进行池化管理
- 延迟加载：对于不常用的数据采用延迟加载策略
- 批量操作：大批量数据处理使用批处理API
- 数据缓存：合理使用多级缓存策略，如本地缓存、Redis缓存
- 资源释放：确保所有资源（如文件、数据库连接）在使用后正确释放
- 代码优化：避免不必要的对象创建、字符串拼接等操作
- 大对象处理：大对象处理应考虑分片、异步处理等策略

## 注释规范
- JavaDoc：所有公共API必须有JavaDoc注释，包括类、接口、方法
- 方法注释：包含参数说明、返回值说明、异常说明等
- 类注释：说明类的作用、设计意图、使用场景等
- 复杂逻辑注释：对于复杂的业务逻辑、算法、特殊处理等，必须添加解释性注释
- TODO注释：使用TODO标记待办事项，格式为 `// TODO: 待办事项描述`
- 废弃代码注释：使用@Deprecated注解并添加详细的废弃原因和替代方案
- 注释风格：保持注释风格统一，简洁明了，避免冗余
- 避免过度注释：代码本身应具有自解释性，注释仅用于解释复杂或不直观的部分